/*
** EPITECH PROJECT, 2020
** server/include/Instance
** File description:
** DO NOT EDIT THIS FILE MANUALLY
*/

#ifndef INSTANCE_HPP_
#define INSTANCE_HPP_

#include <set>
#include <string>
#include "Error.hpp"
#include "Session.hpp"
#include "Proxy.hpp"
#include "Room.hpp"

#include <map>
#include <sstream>
#include <boost/serialization/string.hpp>
#include <boost/archive/text_iarchive.hpp>
#include <boost/archive/text_oarchive.hpp>
#include "commands/IdentifyCommand.hpp"
#include "commands/UpdateCommand.hpp"
#include "commands/UsersCommand.hpp"
#include "commands/CallCommand.hpp"
#include "commands/HangUpCommand.hpp"
#include "commands/MessageCommand.hpp"
#include "events/SelfEvent.hpp"
#include "events/UserEvent.hpp"
#include "events/CallEvent.hpp"
#include "events/HangUpEvent.hpp"
#include "events/MessageEvent.hpp"
#include "events/ErrorEvent.hpp"

// NOTE: need to be sync with NetworkVoice.hpp
#define LOCAL_AUDIO_PORT 7755
#define DATABASE_PATH ".babel.db"

namespace babel {

    /// \brief Instance is the big class where everything is hold
    class Instance {
        public:
            /// \brief Constructor
            Instance();

            /// \brief Destructor
            ~Instance();

            /// \brief Add session to the list
            void join(SessionPtr sessionPtr);

            /// \brief Remove session from the list
            void leave(SessionPtr sessionPtr);

            /// \brief Register a proxy for use
            void join(ProxyPtr proxyPtr);

            /// \brief Handle command from session
            void handleCommand(SessionPtr sessionPtr, std::istream &input) noexcept(true);
        private:

            /// \brief Function which handle IdentifyCommand
            void handleIdentifyCommand(SessionPtr, const commands::IdentifyCommand &);

            /// \brief Function which handle UpdateCommand
            void handleUpdateCommand(SessionPtr, const commands::UpdateCommand &);

            /// \brief Function which handle UsersCommand
            void handleUsersCommand(SessionPtr, const commands::UsersCommand &);

            /// \brief Function which handle CallCommand
            void handleCallCommand(SessionPtr, const commands::CallCommand &);

            /// \brief Function which handle HangUpCommand
            void handleHangUpCommand(SessionPtr, const commands::HangUpCommand &);

            /// \brief Function which handle MessageCommand
            void handleMessageCommand(SessionPtr, const commands::MessageCommand &);

            template<class M, void (babel::Instance::*f)(SessionPtr, const M &)>
            void deserializeCallHandler(SessionPtr session, std::istream &input)
            {
                M a;

                try {
                    boost::archive::text_iarchive ia(input);
                    ia >> a;
                } catch (const std::exception &ex) {
                    throw Error("Failed to deserialize input", "deserializeCallHandler");
                }

                (*this.*f)(session, a);
            }

            template<class M>
            void serializeAndSend(SessionPtr session, const M &a)
            {
                std::stringbuf stringbuf;

                {
                    std::ostream output(&stringbuf);
                    output << a.getMessageName() << " ";
                    boost::archive::text_oarchive oa(output);
                    oa << a;
                }

                session->deliver(stringbuf.str());
            }

            /// \brief Map that store the name of the handler and a wrapper function
            /// that parse the serialize data and call the real handler function
            const std::map<std::string, void (babel::Instance::*)(SessionPtr, std::istream &)> HANDLERS = {
                { "IdentifyCommand", &babel::Instance::deserializeCallHandler
                    <babel::commands::IdentifyCommand, &babel::Instance::handleIdentifyCommand> },
                { "UpdateCommand", &babel::Instance::deserializeCallHandler
                    <babel::commands::UpdateCommand, &babel::Instance::handleUpdateCommand> },
                { "UsersCommand", &babel::Instance::deserializeCallHandler
                    <babel::commands::UsersCommand, &babel::Instance::handleUsersCommand> },
                { "CallCommand", &babel::Instance::deserializeCallHandler
                    <babel::commands::CallCommand, &babel::Instance::handleCallCommand> },
                { "HangUpCommand", &babel::Instance::deserializeCallHandler
                    <babel::commands::HangUpCommand, &babel::Instance::handleHangUpCommand> },
                { "MessageCommand", &babel::Instance::deserializeCallHandler
                    <babel::commands::MessageCommand, &babel::Instance::handleMessageCommand> },
            };
        private:
            /// \brief Notify all session that user have changed
            void notifyUserChangeToUsers(const User &user, User::Status status = User::Status::Online);

            /// \brief Send list of users to the session
            void sendUsersList(SessionPtr session, std::size_t maxUsers = -1);

            /// \brief Send message "from/to"
            template<class M>
            bool sendMessageFromTo(User::Id fromUserId, User::Id toUserId, const M &m)
            {
                bool found = false;

                for (const SessionPtr &session : this->_sessions) {
                    if (session->hasUser() &&
                            session->getUser() == toUserId) {
                        this->serializeAndSend(session, m);
                        found = true;
                    }
                }

                if (found) {
                    for (const SessionPtr &session : this->_sessions) {
                        if (session->hasUser() &&
                                session->getUser() == fromUserId)
                            this->serializeAndSend(session, m);
                    }
                }
                return (found);
            }

        private:
            std::set<RoomPtr> _rooms;
            std::set<SessionPtr> _sessions;
            std::map<User::Id, User> _users;
    };
}

#endif
